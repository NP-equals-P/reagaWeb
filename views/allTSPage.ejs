<html lang="en">
    <head>
        <link rel="stylesheet" href="/styles/allTSStyle.css">
        <link rel="icon" href="./pictures/logo.ico" type="image/x-icon">
        <title> All Runs </title>
        
        <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
        <script type="text/javascript">
            google.charts.load('current', {'packages':['corechart']});

            function compactTS(allTS, sensList) {
                const preData = [["time"]]
                var checkedNum = 0;
                var before;

                for (let k=0; k<sensList.length; k+=1) {
                    
                    if (document.getElementById("butt" + sensList[k]._id).checked) {

                        checkedNum += 1;

                        const sensor = {"measure": sensList[k].name + "(pH)"} //<-- fix this
                        preData[0].push(sensor.measure);                      //<--

                        if (checkedNum == 1) {
                            for (let j=0; j<allTS[k].length; j+=1) {
                                preData.push([allTS[k][j].whenTaken, allTS[k][j].value]);
                            }
                        } else {
                            var oldSize = preData.length;
                            for (let m=0, j=1; j+m<allTS[k].length + preData.length - 1;) {
                                if (preData[j][0] == allTS[k][m].whenTaken) {
                                    preData[j].push(allTS[k][m].value);
                                    m += 1;
                                    j += 1;
                                } else {
                                    before = j;

                                    console.log(j, allTS[k][m].whenTaken)

                                    if (j+m == preData.length + 1) {
                                        console.log("CABOU", j+m)

                                        // for (let b=m; b<allTS[k].length; b+=1) {
                                        //     console.log()
                                        // }

                                        break;


                                    } else {
                                        if ((Date.parse(preData[j][0]) < Date.parse(allTS[k][m].whenTaken) && Date.parse(preData[j+1][0]) > Date.parse(allTS[k][m].whenTaken))) {
                                            const newColl = [allTS[k][m].whenTaken]
    
                                            for (let h=0; h<checkedNum-1; h+=1) {
                                                newColl.push(null);
                                            }
    
                                            newColl.push(allTS[k][m].value);
    
                                            preData.splice(j+1, 0, newColl)
                                            m += 1;
                                        }
    
                                        j += 1;
    
                                        if (preData[before].length == checkedNum) {
                                            preData[before].push(null);
                                        }
                                    }

                                }
                            }
                        }
                    }
                }

                console.log(preData)

                return preData
            }

            async function fillSensors() {

                const reacId = document.getElementById("reacId").value;
                var str = "";
                var aux;

                const getSensorsUrl = "http://localhost:3000/api/reactor/getSensors?reacId=" + reacId;
                const sensorsResponse = await fetch(getSensorsUrl);
                const sensList = await sensorsResponse.json();

                for (let i=0; i<sensList.length; i+=1) {
                    if (i == 0) {
                        aux = "checked";
                    } else {
                        aux = "";
                    }

                    str += "<div class='sensButt'><input id=butt" + sensList[i]._id + " type='checkbox' class='sensCB'" + aux + "><label class='labelGeneric'>" + sensList[i].name + "</label></div>";
                }

                document.getElementById("sensDiv").innerHTML = str;

                return sensList;
            }

            async function drawChart(allTS, sensList) {

                var data;
                var leastFlag = true;

                const singleTS = compactTS(allTS, sensList);

                if (true) {
                    data = google.visualization.arrayToDataTable(singleTS)
                }

                if (leastFlag) {

                    const options = {
                        hartArea: {
                            width: '100%'
                        },
                        title: "Read Values",
                        curveType: 'none',
                        legend: { position: 'bottom' }
                    };

                    const chart = new google.visualization.LineChart(document.getElementById('graphDiv'));
    
                    chart.draw(data, options);
                } else {
                    document.getElementById('graphDiv').innerHTML = ""
                }
            }

            async function showTimeSeries(sensList) {

                const runId = document.getElementById("runId").value;
                const allTS = [];

                for (let i=0; i<sensList.length; i+=1) {
                    const tsUrl = "http://localhost:3000/api/reactor/getRunTS?runId=" + runId + "&sensId=" + sensList[i]._id; 
                        
                    const tsCheck = await fetch(tsUrl);
    
                    const timeSeries = await tsCheck.json();

                    allTS.push(timeSeries)
                }

                drawChart(allTS, sensList);
            }

            async function updateLoop(sensList) {
                while (true) {
                    if (document.getElementById("liveUpdate").value === "true") {
                        await showTimeSeries(sensList)
                    }

                    await new Promise(r => setTimeout(r, 2000));
                }
            }

            async function onLoadFunc() {
                const sensList = await fillSensors()
                await updateLoop(sensList)
            }

            function changeLiveUpdate() {
                if (document.getElementById("liveUpdateCB").checked) {
                    document.getElementById("liveUpdate").value = "true";
                } else {
                    document.getElementById("liveUpdate").value = "false";
                }
            }

        </script>

    </head>
    <body onload="onLoadFunc()">

        <input type="hidden" id="_id" value="<%= user._id %>">
        <input type="hidden" id="reacId" value="<%= reactor._id %>">
        <input type="hidden" id="runId" value="<%= runId %>">

        <input type="hidden" id="liveUpdate" value="true">

        <%- include('./partials/nav.ejs', {name: user.username, _id: user._id}) %>
        <div class="div1">
            <a href="/api/reactor/allRuns?_id=<%= user._id + "&reacId=" + reactor._id%>">
                <button class="backButt">Back</button>
            </a>

            <button class="downloadButt" id="downloadButton">Download Time Series</button>

            <div class="graphDiv" id="graphDiv">
            </div>

            <div class="sensDiv" id="sensDiv">
            </div>

            <div class="controlPanel">
                <label class="labelGeneric">Live Update?</label>
                <input type="checkbox" class="liveUpdateCB" checked id="liveUpdateCB" onchange="changeLiveUpdate()">

                <label class="labelGeneric">Normalized?</label>
                <input type="checkbox" class="normalizedCB" disabled>

                <label class="labelGeneric">Show Events?</label>
                <input type="checkbox" class="eventsCB" disabled>

                <br><br>

                <label class="labelGeneric">Interval Start:</label>
                <input type="date" class="startDate" disabled>
                <input type="time" class="startTime" disabled>

                <br>

                <label class="labelGeneric">Interval End:</label>
                <input type="date" class="endDate" disabled>
                <input type="time" class="endTime" disabled>
            </div>

        </div>
    </body>
</html> 